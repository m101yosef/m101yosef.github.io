---
title: "Advanced Python"
summary: "Data structures, OOP, and Algorithms"
date: 2025-07-30
type: docs
math: true
weight: 1
---

If you know me at all, you will know that I always ecourage thinking over having a knowledge but here I am creating a course on the most theoritical concepts in programming. Understanding OOP, data structures, and algorithms will give you the ability to see what is behind the code; the thinking process that the code creator had. You will be able to see why they structured their code like this or even discover mistakes or ways of improvements.

Also, you should know that I admire learn by doing. In fact, I never understood OOP until I used it to build neural networks in PyTorch or dynamic programming unitl using it for reinforcement learning. So, with no doubt, there will be a lot of practical exercises in this course.


## Course Outline

### Python Foundations (Refresher)

[Lecture 1](lecture1). Code format & performance <br>
[Lecture 2](#). Sequences, comprehensions, zip, enumerate, unpacking <br>
[Lecture 3](#). `*args`, `**kwargs`, `lambda`, `map`, `filter`<br>
[Lecture 4](#). Context managers & exception handling <br>
[Lecture 5](#). Type hinting and static typing (`mypy`, `typing`) <br>

### Object-Oriented Programming (OOP)
[Lecture 6](#). Classes, instances, and constructors (`__init__`) <br>
[Lecture 7](#). Instance, class, and static methods <br>
[Lecture 8](#). Inheritance, polymorphism, and method overriding <br>
[Lecture 9](#). Encapsulation, abstraction, and dunder methods (`__str__`, `__repr__`, etc.) <br>
[Lecture 10](#). Composition vs inheritance + simple design patterns <br>

### Data Stuctures
[Lecture 11](#). Lists, sets, dicts – advanced use cases <br>
[Lecture 12](#). collections: `deque`, `defaultdict`, `Counter`, `namedtuple` <br>
[Lecture 13](#). Stacks and queues using lists and deque <br>
[Lecture 14](#). Singly and doubly linked lists (custom OOP implementation) <br>
[Lecture 15](#). Binary trees and tree traversals (inorder, preorder, postorder) <br>

### Algorithms 
[Lecture 16](#). Big-O notation (time & space complexity) <br>
[Lecture 17](#). Linear & binary search + practice problems <br>
[Lecture 18](#). Sorting algorithms (bubble, insertion, merge, quick) <br>
[Lecture 19](#). recursion & backtracking (with memoisation) <br>
[Lecture 20](#). String algorithms (sliding window, frequency maps) <br>


### Algorithms II
[Lecture 21](#). DFS & BFS in trees and graphs <br>
[Lecture 22](#). Graph implementation (adjacency list, matrix) <br>
[Lecture 23](#). Dijkstra’s algorithm (shortest path) <br>
[Lecture 24](#). Dynamic programming (top-down and bottom-up) <br>
[Lecture 25](#). Greedy algorithms and divide & conquer <br>

### Advance Practices
[Lecture 26](#). Writing testable code + `unittest` or `pytest` <br>
[Lecture 27](#). Debugging with `pdb`, breakpoints, and VS Code tools <br>
[Lecture 28](#). Profiling with `timeit`, `cProfile`, and optimising bottlenecks <br>
[Lecture 29](#). Refactoring and code smells <br>
[Lecture 30](#). Review + final project walkthrough <br>

